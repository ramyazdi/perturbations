#!/usr/bin/env python

from __future__ import division

import sys
import math
logs = sys.stderr
from collections import defaultdict

import numpy

import time
from mytime import Mytime

import gflags as flags
FLAGS=flags.FLAGS

flags.DEFINE_string("weights", None, "weights file (feature instances and weights)", short_name="w")
flags.DEFINE_boolean("featstat", False, "print feature stats")
flags.DEFINE_string("outputweights", None, "write weights (in short-hand format); - for STDOUT", short_name="ow")
flags.DEFINE_boolean("autoeval", True, "use automatically generated eval module")
flags.DEFINE_integer("doublehash", 1, "two-layer hash: weights[action][feature]")
flags.DEFINE_boolean("use_template_id", True, "map template names (\"s0t-s1lct\") to integers")
flags.DEFINE_boolean("tuplefeats", False, "(s0t, s1t) instead of \"s0t-s1t\"")

#from vocab import Vocab
from wvector import WVector # doublehash = 1

class Model(object):
    '''templates and weights.'''

    names = ["SHIFT", "LEFT", "RIGHT"]
    mapnames = {"SHIFT":0, "LEFT":1, "RIGHT":2}
    indent = " " * 4
    eval_module = None # by default, use my handwritten static_eval()

    @staticmethod
    def new_weights(value_class=None):
        return WVector(value_class=value_class)

    def __init__(self, weightstr, noise_info=None):

        Model.start_sym = "<s>"
        Model.stop_sym = "</s>"
        Model.none_sym = "NONE"

        WVector.init(Model.names) # for doublehash 1 (and trim, value_class)

        self.templates = {} # mapping from "s0t-q0t" to the eval expression
        self.list_templates = [] # ordered list of template keys "s0t-q0t"
        self.freq_templates = defaultdict(int)
        self.atomics = set() # atomic features, for computing signature
        
        Model.doublehash = FLAGS.doublehash
        
        self.weights = Model.new_weights() #Vector()
        if not noise_info:
            self.read_weights(weightstr)
        else:
            if not noise_info['noise_file_path']:
                self.read_weights_and_insert_noise(weightstr, noise_info)
            else:
                self.read_weights_and_insert_different_noise(weightstr, noise_info)



##        self.featurenames = set(self.weights.iterkeys())

        if FLAGS.featstat:
            self.print_templates()

    def add_template(self, s, freq=1):
        ## like this: "s0w-s0t=%s|%s" % (s0w, s0t)        
        atomics = s.split("-") # static part: s0w-s0t
        
        if s not in self.templates:
            tid = len(self.templates) if FLAGS.use_template_id else s
            self.templates[s] = tid # template id #compile(tmp, "2", "eval") # no longer used when we have autoeval

            if FLAGS.doublehash == 2:
                ttid = ""
            else:
                ttid = str(tid) + "="
            # new: template id instead of template itself

            if FLAGS.tuplefeats:
                tmp = '(%d, %s)' % (tid, ", ".join(atomics))
            else:                
                tmp = '"%s%s" %% (%s)' % (ttid, \
                                          "|".join(["%s"] * len(atomics)), \
                                          ", ".join(atomics))            

            self.list_templates.append((s, tmp)) # in order

        self.freq_templates[s] += int(freq)
        for atomic in atomics:
            self.atomics.add(atomic)

    def print_autoevals(self):

        tfilename = str(int(time.time()))
        templatefile = open("/tmp/%s.py" % tfilename, "wt")
        
        print >> templatefile, "#generated by model.py"
        print >> templatefile, "import sys; print >> sys.stderr, 'importing succeeded!'"
        print >> templatefile,  "def static_eval((q0w, q0t), (q1w, q1t), (q2w, q2t), (s0w, s0t), (s1w, s1t), (s2w, s2t), (s0lct, s0rct), (s1lct, s1rct)):"
        print >> templatefile,  "%sreturn [" % Model.indent
        
        for s, e in self.list_templates:
            print >> templatefile, "%s%s," % (Model.indent * 2, e)
        
        print >> templatefile, "%s]\n" % (Model.indent * 2)

        # signature:
        print >> templatefile, "def signature((s0w, s0t), (s1w, s1t), (s2w, s2t), (s0lct, s0rct), (s1lct, s1rct)):"
        print >> templatefile, "%sreturn (" % Model.indent # hashable tuple
        for atomic in sorted(self.atomics):
            if atomic[0] != "q": # signature does not include info on queue
                print >> templatefile, "%s%s," % (Model.indent * 2, atomic)
        print >> templatefile, "%s)" % (Model.indent * 2)            
        
        templatefile.close()

        if FLAGS.autoeval:
            sys.path.append('/tmp/')
            print >> logs, "importing auto-generated file /tmp/%s.py" % tfilename
            Model.eval_module = __import__(tfilename)
        else:
            Model.eval_module = Model        
        
    def print_templates(self, f=logs):
        print >> f, ">>> %d templates in total:" % len(self.templates)
        print >> f, "\n".join(["%-20s\t%d" % (x, self.freq_templates[x]) \
                               for x, _ in self.list_templates])
        print >> f, "---"

    def read_templates(self, filename):

        ## try interpreting it as a filename, if failed, then as a string
        try:
            f = open(filename)
            print >> logs, "reading templates from %s" % filename,
            for x in f:
                if x[:3] == "---":
                    break
                if x[:3] == ">>>":
                    continue
                try:
                    s, freq = x.split()
                except:
                    s, freq = x, 1
                self.add_template(s, freq)                
        
        except:
            print >> logs, "BAD TEMPLATES FILE:", filename
            exit(1)
##            ## from argv string rather than file
##            for x in filename.split():
##                self.add_template(x)
##            f = None

        print >> logs, "%d feature templates read." % len(self.templates)

        return f

    def read_weights(self, filename, infertemplates=False):
        '''instances are like "s0t-q0t=LRB-</s>=>LEFT     3.8234"'''
        infile = self.read_templates(filename)

        infertemplates = len(self.templates) <= 1
        if infertemplates:
            print >> logs, "will infer templates from weights..."        

        mytime = Mytime()
        i = 0
        if infile is not None:
            print >> logs, "reading feature weights from %s\t" % filename,
            for i, line in enumerate(infile, 1):
                if i % 200000 == 0:
                    print >> logs, "%d lines read..." % i,

                feat, weight = line.split()
                weight = float(weight) #WVector.value_class(float(weight)) # in case of mydouble
                
                if FLAGS.use_template_id:
                    template, instance = feat.split("=", 1)
                    tid = self.templates[template]
                    feat = "%d=%s" % (tid, instance)
                    
                if Model.doublehash == 1:
                    if FLAGS.tuplefeats:
                        f, action = instance.rsplit("=>", 1)
                        #action = Model.mapnames[action]                    
                        fs = tuple(f.split("|"))
                        self.weights[action][(tid, ) + fs] = weight
                    else:
                        f, action = feat.rsplit("=>", 1)
                        #action = Model.mapnames[action]                    
                        self.weights[action][f] = weight
                        
                elif Model.doublehash == 2:
                    f, action = instance.rsplit("=>", 1)
                    action = Model.mapnames[action]
                    self.weights[action][tid][f] = weight
                else:
                    self.weights[feat] = weight

                if infertemplates:
                    self.add_template(feat.split("=", 1)[0], 1) ## one occurrence

        print >> logs, "\n%d feature instances (%d lines) read in %.2lf seconds." % \
              (len(self.weights), i, mytime.period())

        self.print_autoevals()

    def read_weights_and_insert_noise(self, filename, noise_info ,infertemplates=False):
        # ADDED CODE HERE
        '''instances are like "s0t-q0t=LRB-</s>=>LEFT     3.8234"'''

        """
            noise_info = {
                'method': FLAGS.noise_method,
                'mu': FLAGS.mu,
                'sigma': FLAGS.sigma,
                'noise_file_path': FLAGS.noise_file_path,
        }
        """
        method = noise_info['method']
        mu = noise_info['mu']
        sigma = noise_info['sigma']

        infile = self.read_templates(filename)

        infertemplates = len(self.templates) <= 1
        if infertemplates:
            print >> logs, "will infer templates from weights..."

        mytime = Mytime()
        i = 0
        if infile is not None:
            print >> logs, "reading feature weights from %s\t" % filename,
            for i, line in enumerate(infile, 1):
                if i % 200000 == 0:
                    print >> logs, "%d lines read..." % i,

                feat, weight = line.split()
                weight = float(weight)  # WVector.value_class(float(weight)) # in case of mydouble
                noise_ = float(sigma) * numpy.random.randn() + float(mu)

                if method == 'a':
                    weight = weight + noise_
                elif method == 'm':
                    weight = weight * noise_

                if FLAGS.use_template_id:
                    template, instance = feat.split("=", 1)
                    tid = self.templates[template]
                    feat = "%d=%s" % (tid, instance)

                if Model.doublehash == 1:
                    if FLAGS.tuplefeats:
                        f, action = instance.rsplit("=>", 1)
                        # action = Model.mapnames[action]
                        fs = tuple(f.split("|"))
                        self.weights[action][(tid,) + fs] = weight
                    else:
                        f, action = feat.rsplit("=>", 1)
                        # action = Model.mapnames[action]
                        self.weights[action][f] = weight

                elif Model.doublehash == 2:
                    f, action = instance.rsplit("=>", 1)
                    action = Model.mapnames[action]
                    self.weights[action][tid][f] = weight
                else:
                    self.weights[feat] = weight

                if infertemplates:
                    self.add_template(feat.split("=", 1)[0], 1)  ## one occurrence

        print >> logs, "\n%d feature instances (%d lines) read in %.2lf seconds." % \
                       (len(self.weights), i, mytime.period())

        self.print_autoevals()


    def read_weights_and_insert_different_noise(self, filename, noise_info ,infertemplates=False):
        # ADDED CODE HERE
        '''instances are like "s0t-q0t=LRB-</s>=>LEFT     3.8234"'''

        """
            noise_info = {
                'method': FLAGS.noise_method,
                'mu': FLAGS.mu,
                'sigma': FLAGS.sigma,
                'noise_file_path': FLAGS.noise_file_path,
        }
        """
        method = noise_info['method']
        mu = noise_info['mu']
        sigma = noise_info['sigma']
        noise_file_path = noise_info['noise_file_path']
        noises_vector = numpy.load(noise_file_path)

        infile = self.read_templates(filename)

        infertemplates = len(self.templates) <= 1
        if infertemplates:
            print >> logs, "will infer templates from weights..."

        mytime = Mytime()
        i = 0
        if infile is not None:
            print >> logs, "reading feature weights from %s\t" % filename,
            # for i, line in enumerate(infile, 1):
            for i, (line, noises_vector_coeff) in enumerate(zip(infile, noises_vector), 1):

                if i % 200000 == 0:
                    print >> logs, "%d lines read..." % i,

                feat, weight = line.split()
                weight = float(weight)  # WVector.value_class(float(weight)) # in case of mydouble
                noise_ = float(noises_vector_coeff) * numpy.random.randn() + float(mu)

                if method == 'a':
                    weight = weight + noise_
                elif method == 'm':
                    weight = weight * noise_

                if FLAGS.use_template_id:
                    template, instance = feat.split("=", 1)
                    tid = self.templates[template]
                    feat = "%d=%s" % (tid, instance)

                if Model.doublehash == 1:
                    if FLAGS.tuplefeats:
                        f, action = instance.rsplit("=>", 1)
                        # action = Model.mapnames[action]
                        fs = tuple(f.split("|"))
                        self.weights[action][(tid,) + fs] = weight
                    else:
                        f, action = feat.rsplit("=>", 1)
                        # action = Model.mapnames[action]
                        self.weights[action][f] = weight

                elif Model.doublehash == 2:
                    f, action = instance.rsplit("=>", 1)
                    action = Model.mapnames[action]
                    self.weights[action][tid][f] = weight
                else:
                    self.weights[feat] = weight

                if infertemplates:
                    self.add_template(feat.split("=", 1)[0], 1)  ## one occurrence

        print >> logs, "\n%d feature instances (%d lines) read in %.2lf seconds." % \
                       (len(self.weights), i, mytime.period())

        self.print_autoevals()


    def make_feats(self, state):
        '''returns a *list* of feature templates for state.'''
        
        fv = new_vector() #Vector()
        top = state.top()
        topnext = state.top(1)
        top3rd = state.top(2)
        qhead = state.qhead()
        qnext = state.qhead(1)

        ## this part is manual; their combinations are automatic
        s0 = top.head() if top is not None else ("<s>", "<s>") # N.B. (...)
        s1 = topnext.head() if topnext is not None else ("<s>", "<s>") 
        s2 = top3rd.head() if top3rd is not None else ("<s>", "<s>") 

        q0 = qhead if qhead is not None else ("</s>", "</s>") 
        q1 = qnext if qnext is not None else ("</s>", "</s>")

        s0lct = top.lefts[0].tag() if (top is not None and len(top.lefts) > 0) else "NONE"
        s0rct = top.rights[-1].tag() if (top is not None and len(top.rights) > 0) else "NONE"
        s1lct = topnext.lefts[0].tag() if (topnext is not None and len(topnext.lefts) > 0) else "NONE"
        s1rct = topnext.rights[-1].tag() if (topnext is not None and len(topnext.rights) > 0) else "NONE"
        
        ## like this: "s0w-s0t=%s|%s" % (s0w, s0t) ---> returns a list here!
        return Model.static_eval(q0, q1, s0, s1, s2, (s0lct, s0rct), (s1lct, s1rct))
#        return [eval(t) for t in self.templates.values()] ## eval exprs are the values, not keys

    def write(self, filename="-", weights=None):

        if filename is None:
            print >> logs, "dumping of weights skipped."
            return

        if weights is None:
            weights = self.weights

        if filename == "-":
            outfile = sys.stdout
            filename = "STDOUT"  # careful overriding
        else:
            outfile = open(filename, "wt")

        self.print_templates(outfile)

        mytime = Mytime()

        nonzero = 0
        # my wvector
        for action, feats in weights.iteritems():
            for f in sorted(feats):
                v = feats[f]
                if math.fabs(float(v)) > 1e-3: # TODO
                    tid, feat = f.split("=", 1)
                    print >> outfile, "%s=%s=>%s\t%.5lf" % (self.list_templates[int(tid)][0], feat, action, float(v))
                    nonzero += 1

        print >> logs, "%d nonzero feature instances written in %.2lf seconds." % \
              (nonzero, mytime.period())  ## nonzero != i

    @staticmethod
    def _trim(fv):
        for f, v in fv.iteritems():
            if math.fabs(v) < 1e-3:
                del fv[f]
        return fv

    @staticmethod
    def _trim2(fv):
        for f, v in fv.items():
            if v == 0:  # int for wvector
                del fv[f]
        return fv

    @staticmethod
    def trim(fv):
        ## looks like doublehash 1
        for feats in fv.values():
            Model._trim2(feats)
        return fv

    @staticmethod
    def static_eval((q0w, q0t), (q1w, q1t), (s0w, s0t), (s1w, s1t), (s2w, s2t), (s0lct, s0rct), (s1lct, s1rct)):
        return ["q0t=%s" % (q0t),
                "q0w-q0t=%s|%s" % (q0w, q0t),
                "q0w=%s" % (q0w),
                "s0t-q0t-q1t=%s|%s|%s" % (s0t, q0t, q1t),
                "s0t-q0t=%s|%s" % (s0t, q0t),
                "s0t-s1t=%s|%s" % (s0t, s1t),
                "s0t-s1w-s1t=%s|%s|%s" % (s0t, s1w, s1t),
                "s0t=%s" % (s0t),
                "s0w-q0t-q1t=%s|%s|%s" % (s0w, q0t, q1t),
                "s0w-s0t-s1t=%s|%s|%s" % (s0w, s0t, s1t),
                "s0w-s0t-s1w-s1t=%s|%s|%s|%s" % (s0w, s0t, s1w, s1t),
                "s0w-s0t-s1w=%s|%s|%s" % (s0w, s0t, s1w),
                "s0w-s0t=%s|%s" % (s0w, s0t),
                "s0w-s1w-s1t=%s|%s|%s" % (s0w, s1w, s1t),
                "s0w-s1w=%s|%s" % (s0w, s1w),
                "s0w=%s" % (s0w),
                "s1t-s0t-q0t=%s|%s|%s" % (s1t, s0t, q0t),
                "s1t-s0t-s0lct=%s|%s|%s" % (s1t, s0t, s0lct),
                "s1t-s0t-s0rct=%s|%s|%s" % (s1t, s0t, s0rct),
                "s1t-s0w-q0t=%s|%s|%s" % (s1t, s0w, q0t),
                "s1t-s0w-s0lct=%s|%s|%s" % (s1t, s0w, s0lct),
                "s1t-s1lct-s0t=%s|%s|%s" % (s1t, s1lct, s0t),
                "s1t-s1lct-s0w=%s|%s|%s" % (s1t, s1lct, s0w),
                "s1t-s1rct-s0t=%s|%s|%s" % (s1t, s1rct, s0t),
                "s1t-s1rct-s0w=%s|%s|%s" % (s1t, s1rct, s0w),
                "s1t=%s" % (s1t),
                "s1w-s1t=%s|%s" % (s1w, s1t),
                "s1w=%s" % (s1w),
                "s2t-s1t-s0t=%s|%s|%s" % (s2t, s1t, s0t)]

    def prune(self, filenames):
        '''prune features from word/tag lines'''

        print >> logs, "pruning features using %s..." % filenames,
        
        fullset = set()
        for filename in filenames.split():
            for l in open(filename):
                for w, t in map(lambda x:x.rsplit("/", 1), l.split()):
                    fullset.add(w)
                    fullset.add(t)

        print >> logs, "collected %d uniq words & tags..." % (len(fullset)),

        new = new_vector() # Vector()
        for f in self.weights:

            stuff = f.split("=", 1)[1].rsplit("=", 1)[0].split("|")  ## b/w 1st and last "=", but caution
            for s in stuff:
                if s not in fullset:
                    break
            else:
                new[f] = self.weights[f]

        print >> logs, "%d features survived (ratio: %.2f)" % (len(new), len(new) / len(self.weights))
        self.weights = new

    def sparsify(self, z=1):
        '''duchi et al., 2008'''
        
        

if __name__ == "__main__":

    flags.DEFINE_string("prune", None, "prune features w.r.t. FILE (word/tag format)")

    try:
        argv = FLAGS(sys.argv)
        if FLAGS.weights is None:
            raise flags.FlagsError("must specify weights by -w ...")
    except flags.FlagsError, e:
        print >> logs, 'Error: %s\nUsage: %s ARGS\n%s' % (e, sys.argv[0], FLAGS)
        sys.exit(1)
    
    FLAGS.featstat = True
    
    model = Model(FLAGS.weights) #.model, FLAGS.weights)

    if FLAGS.prune:
        model.prune(FLAGS.prune)

    if FLAGS.outputweights:
        model.write(FLAGS.outputweights)
